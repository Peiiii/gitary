import{s as e}from"./rolldown-runtime-B6ubh40S.js";import{N as t,P as n,w as r}from"./chakra-ui-DL3iEWi3.js";import{k as i}from"./react-utils-C9u-5Qte.js";import{t as a}from"./vendor-Ddcx14uX.js";import"./common-utils-6spi2Ajg.js";import"./monaco-BOU7eshl.js";import"./react-markdown-CyVVEHR3.js";import"./remark-gfm-DTA0tSXW.js";import{L as o,Q as s,Qn as c,U as l,W as u,_ as d,_n as f,ar as p,h as m,hi as h,jn as g,k as _,nt as v,or as y,q as b,sr as x,st as S,u as C,w,z as T}from"./app-HD19YyAJ.js";import{t as E}from"./_baseUniq-214847ec-gYkodkzP.js";import{u as D}from"./_basePickBy-f749536a-DMdLDBu1.js";import{t as O}from"./clone-8a8d8292-C4Vc3bpo.js";import{t as k}from"./graph-355e244d-CtTgE9d0.js";import{t as A}from"./layout-7ea0beed-8PH-dp64.js";t(),n(),a(),r(),i(),x(),y(),h(),p();function j(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:M(e),edges:N(e)};return E(e.graph())||(t.value=O(e.graph())),t}function M(e){return D(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),i={v:t};return E(n)||(i.value=n),E(r)||(i.parent=r),i})}function N(e){return D(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return E(t.name)||(r.name=t.name),E(n)||(r.value=n),r})}var P=new Map,F=new Map,I=new Map,L=f(()=>{F.clear(),I.clear(),P.clear()},`clear`),R=f((e,t)=>{let n=F.get(t)||[];return S.trace(`In isDescendant`,t,` `,e,` = `,n.includes(e)),n.includes(e)},`isDescendant`),z=f((e,t)=>{let n=F.get(t)||[];return S.info(`Descendants of `,t,` is `,n),S.info(`Edge is `,e),e.v===t||e.w===t?!1:n?n.includes(e.v)||R(e.v,t)||R(e.w,t)||n.includes(e.w):(S.debug(`Tilt, `,t,`,not in descendants`),!1)},`edgeInCluster`),B=f((e,t,n,r)=>{S.warn(`Copying children of `,e,`root`,r,`data`,t.node(e),r);let i=t.children(e)||[];e!==r&&i.push(e),S.warn(`Copying (nodes) clusterId`,e,`nodes`,i),i.forEach(i=>{if(t.children(i).length>0)B(i,t,n,r);else{let a=t.node(i);S.info(`cp `,i,` to `,r,` with parent `,e),n.setNode(i,a),r!==t.parent(i)&&(S.warn(`Setting parent`,i,t.parent(i)),n.setParent(i,t.parent(i))),e!==r&&i!==e?(S.debug(`Setting parent`,i,e),n.setParent(i,e)):(S.info(`In copy `,e,`root`,r,`data`,t.node(e),r),S.debug(`Not Setting parent for node=`,i,`cluster!==rootId`,e!==r,`node!==clusterId`,i!==e));let o=t.edges(i);S.debug(`Copying Edges`,o),o.forEach(i=>{S.info(`Edge`,i);let a=t.edge(i.v,i.w,i.name);S.info(`Edge data`,a,r);try{z(i,r)?(S.info(`Copying as `,i.v,i.w,a,i.name),n.setEdge(i.v,i.w,a,i.name),S.info(`newGraph edges `,n.edges(),n.edge(n.edges()[0]))):S.info(`Skipping copy of edge `,i.v,`-->`,i.w,` rootId: `,r,` clusterId:`,e)}catch(e){S.error(e)}})}S.debug(`Removing node`,i),t.removeNode(i)})},`copy`),V=f((e,t)=>{let n=t.children(e),r=[...n];for(let i of n)I.set(i,e),r=[...r,...V(i,t)];return r},`extractDescendants`),H=f((e,t,n)=>{let r=e.edges().filter(e=>e.v===t||e.w===t),i=e.edges().filter(e=>e.v===n||e.w===n),a=r.map(e=>({v:e.v===t?n:e.v,w:e.w===t?t:e.w})),o=i.map(e=>({v:e.v,w:e.w}));return a.filter(e=>o.some(t=>e.v===t.v&&e.w===t.w))},`findCommonEdges`),U=f((e,t,n)=>{let r=t.children(e);if(S.trace(`Searching children of id `,e,r),r.length<1)return e;let i;for(let e of r){let r=U(e,t,n),a=H(t,n,r);if(r)if(a.length>0)i=r;else return r}return i},`findNonClusterChild`),W=f(e=>!P.has(e)||!P.get(e).externalConnections?e:P.has(e)?P.get(e).id:e,`getAnchorId`),G=f((e,t)=>{if(!e||t>10){S.debug(`Opting out, no graph `);return}else S.debug(`Opting in, graph `);e.nodes().forEach(function(t){e.children(t).length>0&&(S.warn(`Cluster identified`,t,` Replacement id in edges: `,U(t,e,t)),F.set(t,V(t,e)),P.set(t,{id:U(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){let n=e.children(t),r=e.edges();n.length>0?(S.debug(`Cluster identified`,t,F),r.forEach(e=>{R(e.v,t)^R(e.w,t)&&(S.warn(`Edge: `,e,` leaves cluster `,t),S.warn(`Descendants of XXX `,t,`: `,F.get(t)),P.get(t).externalConnections=!0)})):S.debug(`Not a cluster `,t,F)});for(let t of P.keys()){let n=P.get(t).id,r=e.parent(n);r!==t&&P.has(r)&&!P.get(r).externalConnections&&(P.get(t).id=r)}e.edges().forEach(function(t){let n=e.edge(t);S.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(t)),S.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(e.edge(t)));let r=t.v,i=t.w;if(S.warn(`Fix XXX`,P,`ids:`,t.v,t.w,`Translating: `,P.get(t.v),` --- `,P.get(t.w)),P.get(t.v)||P.get(t.w)){if(S.warn(`Fixing and trying - removing XXX`,t.v,t.w,t.name),r=W(t.v),i=W(t.w),e.removeEdge(t.v,t.w,t.name),r!==t.v){let i=e.parent(r);P.get(i).externalConnections=!0,n.fromCluster=t.v}if(i!==t.w){let r=e.parent(i);P.get(r).externalConnections=!0,n.toCluster=t.w}S.warn(`Fix Replacing with XXX`,r,i,t.name),e.setEdge(r,i,n,t.name)}}),S.warn(`Adjusted Graph`,j(e)),K(e,0),S.trace(P)},`adjustClustersAndEdges`),K=f((e,t)=>{var n;if(S.warn(`extractor - `,t,j(e),e.children(`D`)),t>10){S.error(`Bailing out`);return}let r=e.nodes(),i=!1;for(let t of r){let n=e.children(t);i||=n.length>0}if(!i){S.debug(`Done, no node has children`,e.nodes());return}S.debug(`Nodes = `,r,t);for(let i of r)if(S.debug(`Extracting node`,i,P,P.has(i)&&!P.get(i).externalConnections,!e.parent(i),e.node(i),e.children(`D`),` Depth `,t),!P.has(i))S.debug(`Not a cluster`,i,t);else if(!P.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){S.warn(`Cluster without external connections, without a parent and with children`,i,t);let r=e.graph().rankdir===`TB`?`LR`:`TB`;(n=P.get(i)?.clusterData)!=null&&n.dir&&(r=P.get(i).clusterData.dir,S.warn(`Fixing dir`,P.get(i).clusterData.dir,r));let a=new k({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});S.warn(`Old graph before copy`,j(e)),B(i,e,a,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:P.get(i).clusterData,label:P.get(i).label,graph:a}),S.warn(`New graph after copy node: (`,i,`)`,j(a)),S.debug(`Old graph after copy`,j(e))}else S.warn(`Cluster ** `,i,` **not meeting the criteria !externalConnections:`,!P.get(i).externalConnections,` no parent: `,!e.parent(i),` children `,e.children(i)&&e.children(i).length>0,e.children(`D`),t),S.debug(P);r=e.nodes(),S.warn(`New list of nodes`,r);for(let n of r){let r=e.node(n);S.warn(` Now next level`,n,r),r!=null&&r.clusterNode&&K(r.graph,t+1)}},`extractor`),q=f((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(t=>{let r=q(e,e.children(t));n=[...n,...r]}),n},`sorter`),J=f(e=>q(e,e.children()),`sortNodesByHierarchy`),Y=f(async(e,t,n,r,i,a)=>{S.warn(`Graph in recursive render:XAX`,j(t),i);let c=t.graph().rankdir;S.trace(`Dir in recursive render - dir:`,c);let p=e.insert(`g`).attr(`class`,`root`);t.nodes()?S.info(`Recursive render XXX`,t.nodes()):S.info(`No nodes found for`,t),t.edges().length>0&&S.info(`Recursive edges`,t.edge(t.edges()[0]));let h=p.insert(`g`).attr(`class`,`clusters`),_=p.insert(`g`).attr(`class`,`edgePaths`),v=p.insert(`g`).attr(`class`,`edgeLabels`),y=p.insert(`g`).attr(`class`,`nodes`);await Promise.all(t.nodes().map(async function(e){let u=t.node(e);if(i!==void 0){let n=JSON.parse(JSON.stringify(i.clusterData));S.trace(`Setting data for parent cluster XXX
 Node.id = `,e,`
 data=`,n.height,`
Parent cluster`,i.height),t.setNode(i.id,n),t.parent(e)||(S.trace(`Setting parent`,e,i.id),t.setParent(e,i.id,n))}if(S.info(`(Insert) Node XXX`+e+`: `+JSON.stringify(t.node(e))),u!=null&&u.clusterNode){S.info(`Cluster identified XBX`,e,u.width,t.node(e));let{ranksep:i,nodesep:s}=t.graph();u.graph.setGraph({...u.graph.graph(),ranksep:i+25,nodesep:s});let c=await Y(y,u.graph,n,r,t.node(e),a),d=c.elem;o(u,d),u.diff=c.diff||0,S.info(`New compound node after recursive render XAX`,e,`width`,u.width,`height`,u.height),l(d,u)}else t.children(e).length>0?(S.trace(`Cluster - the non recursive path XBX`,e,u.id,u,u.width,`Graph:`,t),S.trace(U(u.id,t)),P.set(u.id,{id:U(u.id,t),node:u})):(S.trace(`Node - the non recursive path XAX`,e,y,t.node(e),c),await s(y,t.node(e),{config:a,dir:c}))})),await f(async()=>{let e=t.edges().map(async function(e){let n=t.edge(e.v,e.w,e.name);S.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e)),S.info(`Edge `+e.v+` -> `+e.w+`: `,e,` `,JSON.stringify(t.edge(e))),S.info(`Fix`,P,`ids:`,e.v,e.w,`Translating: `,P.get(e.v),P.get(e.w)),await w(v,n)});await Promise.all(e)},`processEdges`)(),S.info(`Graph before layout:`,JSON.stringify(j(t))),S.info(`############################################# XXX`),S.info(`###                Layout                 ### XXX`),S.info(`############################################# XXX`),A(t),S.info(`Graph after layout:`,JSON.stringify(j(t)));let b=0,{subGraphTitleTotalMargin:x}=T(a);return await Promise.all(J(t).map(async function(e){let n=t.node(e);if(S.info(`Position XBX => `+e+`: (`+n.x,`,`+n.y,`) width: `,n.width,` height: `,n.height),n!=null&&n.clusterNode)n.y+=x,S.info(`A tainted cluster node XBX1`,e,n.id,n.width,n.height,n.x,n.y,t.parent(e)),P.get(n.id).node=n,m(n);else if(t.children(e).length>0){S.info(`A pure cluster node XBX1`,e,n.id,n.x,n.y,n.width,n.height,t.parent(e)),n.height+=x,t.node(n.parentId);let r=n?.padding/2||0,i=n?.labelBBox?.height||0,a=i-r||0;S.debug(`OffsetY`,a,`labelHeight`,i,`halfPadding`,r),await g(h,n),P.get(n.id).node=n}else{let e=t.node(n.parentId);n.y+=x/2,S.info(`A regular node XBX1 - using the padding`,n.id,`parent`,n.parentId,n.width,n.height,n.x,n.y,`offsetY`,n.offsetY,`parent`,e,e?.offsetY,n),m(n)}})),t.edges().forEach(function(e){let i=t.edge(e);S.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(i),i),i.points.forEach(e=>e.y+=x/2),u(i,d(_,i,P,n,t.node(e.v),t.node(e.w),r))}),t.nodes().forEach(function(e){let n=t.node(e);S.info(e,n.type,n.diff),n.isGroup&&(b=n.diff)}),S.warn(`Returning from recursive render XAX`,p,b),{elem:p,diff:b}},`recursiveRender`),X=f(async(e,t)=>{let n=new k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),r=t.select(`g`);v(r,e.markers,e.type,e.diagramId),C(),_(),b(),L(),e.nodes.forEach(e=>{n.setNode(e.id,{...e}),e.parentId&&n.setParent(e.id,e.parentId)}),S.debug(`Edges:`,e.edges),e.edges.forEach(e=>{if(e.start===e.end){let t=e.start,r=t+`---`+t+`---1`,i=t+`---`+t+`---2`,a=n.node(t);n.setNode(r,{domId:r,id:r,parentId:a.parentId,labelStyle:``,label:``,padding:0,shape:`labelRect`,style:``,width:10,height:10}),n.setParent(r,a.parentId),n.setNode(i,{domId:i,id:i,parentId:a.parentId,labelStyle:``,padding:0,shape:`labelRect`,label:``,style:``,width:10,height:10}),n.setParent(i,a.parentId);let o=structuredClone(e),s=structuredClone(e),c=structuredClone(e);o.label=``,o.arrowTypeEnd=`none`,o.id=t+`-cyclic-special-1`,s.arrowTypeStart=`none`,s.arrowTypeEnd=`none`,s.id=t+`-cyclic-special-mid`,c.label=``,a.isGroup&&(o.fromCluster=t,c.toCluster=t),c.id=t+`-cyclic-special-2`,c.arrowTypeStart=`none`,n.setEdge(t,r,o,t+`-cyclic-special-0`),n.setEdge(r,i,s,t+`-cyclic-special-1`),n.setEdge(i,t,c,t+`-cyc<lic-special-2`)}else n.setEdge(e.start,e.end,{...e},e.id)}),S.warn(`Graph at first:`,JSON.stringify(j(n))),G(n),S.warn(`Graph after XAX:`,JSON.stringify(j(n)));let i=c();await Y(r,n,e.type,e.diagramId,void 0,i)},`render`);export{X as render};